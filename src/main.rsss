use lazy_static::{lazy_static};
use serde::{Serialize, Deserialize};
use std::{env, thread, time, fs, string::String, collections::HashMap, collections::HashSet};
use std::sync::mpsc::{channel, Sender, Receiver, TryRecvError};

use my_notify::*;
use my_rustsync::*;

use rusoto_core::{Region};
use rusoto_sqs::{Sqs, SqsClient, ListQueueTagsRequest, CreateQueueRequest, DeleteMessageBatchRequest,
                 DeleteMessageBatchRequestEntry, ReceiveMessageRequest, SendMessageRequest, ReceiveMessageResult, Message};
use rusoto_s3::{S3, S3Client, HeadBucketRequest, PutObjectRequest, GetObjectRequest, StreamingBody};
use std::io::prelude::*;
use tokio::io;
use std::sync::{Arc, RwLock, Mutex};
use pickledb::{PickleDb, PickleDbDumpPolicy};
use walkdir::WalkDir;

fn main() {

    /* thread gets access to variables from outer scope */
    thread::sleep(time::Duration::from_secs(1));
    let (notify_tx, notify_rx) = channel();
    let mut watcher = watcher(notify_tx, time::Duration::from_millis(5000)).unwrap();

    for entry in WalkDir::new("/opt/sync") {
        // println!("entry: {}", &entry.unwrap().path().display());
        watcher.watch(entry.unwrap().path(), RecursiveMode::NonRecursive).unwrap();
    }

    // watcher.unwatch("/opt/sync/file3");
    // watcher.unwatch("/opt/sync/dir3");
    // watcher.unwatch("/opt/sync/dir3/file1");

    /* main watcher event loop */
    loop {
        /* block until there is an event to be handled (nothing else to do) */
        match notify_rx.recv() {
            Ok(event) => {
                println!("event: {:?}", event);
                // println!("res: {:?}", watcher.unwatch("/opt/sync/file3"));
                /* received the event, now process it */
            },
            /* something went horribly wrong, inotify possibly broken or dead channel, log it */
            Err(e) => {
            },
        }
    }

}
